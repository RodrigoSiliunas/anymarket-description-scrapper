"""
==========================================================================
 ‚û† Data Wrangler Module
 ‚û† Section By: Rodrigo Siliunas
 ‚û† Related system: Data Processing / Transformation
==========================================================================
"""

import json
import time
import re
from typing import List, Dict, Optional, Any
from pathlib import Path


class DataWrangler:
    """
    Classe respons√°vel pelo processamento e transforma√ß√£o de dados extra√≠dos
    de documenta√ß√£o de APIs.
    """

    def __init__(self, data_path: Path):
        """
        Inicializa o DataWrangler com o caminho dos dados.
        
        Args:
            data_path (Path): Caminho para o diret√≥rio contendo os arquivos de dados
        """
        self.data_path = Path(data_path)
        self.output_path = self.data_path / "out"  # Pasta de sa√≠da
        self.processed_files = []
        self.errors = []
        
        # Verifica se o caminho existe
        if not self.data_path.exists():
            raise FileNotFoundError(f"Caminho n√£o encontrado: {self.data_path}")
        
        if not self.data_path.is_dir():
            raise NotADirectoryError(f"O caminho deve ser um diret√≥rio: {self.data_path}")
        
        # Cria a pasta de sa√≠da se n√£o existir
        self.output_path.mkdir(parents=True, exist_ok=True)
        
        print(f"‚úÖ DataWrangler inicializado")
        print(f"   üìÅ Entrada: {self.data_path}")
        print(f"   üìÅ Sa√≠da: {self.output_path}")

    def detect_files(self, file_extension: str = "json") -> List[Path]:
        """
        Detecta automaticamente todos os arquivos com a extens√£o especificada no diret√≥rio.
        
        Args:
            file_extension (str): Extens√£o dos arquivos a serem detectados (sem o ponto)
            
        Returns:
            List[Path]: Lista de caminhos dos arquivos encontrados
        """
        try:
            # Remove o ponto da extens√£o se fornecido
            extension = file_extension.lstrip(".")
            
            # Busca por arquivos com a extens√£o especificada
            pattern = f"*.{extension}"
            found_files = list(self.data_path.glob(pattern))
            
            # Filtra apenas arquivos (n√£o diret√≥rios)
            files = [f for f in found_files if f.is_file()]
            
            print(f"üîç Detectados {len(files)} arquivo(s) .{extension}")
            
            for file in files:
                print(f"   üìÑ {file.name}")
            
            return files
            
        except Exception as e:
            error_msg = f"Erro ao detectar arquivos: {e}"
            print(f"‚ùå {error_msg}")
            self.errors.append(error_msg)
            return []

    def load_json_file(self, file_path: Path) -> Optional[Dict[str, Any]]:
        """
        Carrega um arquivo JSON e retorna seu conte√∫do.
        
        Args:
            file_path (Path): Caminho para o arquivo JSON
            
        Returns:
            Optional[Dict[str, Any]]: Conte√∫do do arquivo JSON ou None se houver erro
        """
        try:
            with open(file_path, 'r', encoding='utf-8') as file:
                data = json.load(file)
            
            print(f"‚úÖ Carregado: {file_path.name}")
            return data
            
        except json.JSONDecodeError as e:
            error_msg = f"Erro de JSON em {file_path.name}: {e}"
            print(f"‚ùå {error_msg}")
            self.errors.append(error_msg)
            return None
            
        except Exception as e:
            error_msg = f"Erro ao carregar {file_path.name}: {e}"
            print(f"‚ùå {error_msg}")
            self.errors.append(error_msg)
            return None

    def save_json_file(self, data: Dict[str, Any], file_path: Path) -> bool:
        """
        Salva dados em um arquivo JSON.
        
        Args:
            data (Dict[str, Any]): Dados a serem salvos
            file_path (Path): Caminho onde salvar o arquivo
            
        Returns:
            bool: True se salvou com sucesso, False caso contr√°rio
        """
        try:
            with open(file_path, 'w', encoding='utf-8') as file:
                json.dump(data, file, indent=4, ensure_ascii=False)
            
            print(f"üíæ Salvo: {file_path.name}")
            return True
            
        except Exception as e:
            error_msg = f"Erro ao salvar {file_path.name}: {e}"
            print(f"‚ùå {error_msg}")
            self.errors.append(error_msg)
            return False

    def camel_to_snake_case(self, name: str) -> str:
        """
        Converte camelCase ou PascalCase para snake_case.
        
        Exemplos:
        - stockLocal_priorityPoints -> stock_local_priority_points
        - stockLocal_defaultLocal -> stock_local_default_local
        - categoryId -> category_id
        - firstName -> first_name
        
        Args:
            name (str): Nome em camelCase ou PascalCase
            
        Returns:
            str: Nome convertido para snake_case
        """
        # Primeira convers√£o: adiciona underscore antes de mai√∫sculas
        # stockLocalPriorityPoints -> stock_Local_Priority_Points
        s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
        
        # Segunda convers√£o: adiciona underscore antes de mai√∫sculas seguidas de min√∫sculas
        # stock_LocalPriority_Points -> stock_Local_Priority_Points
        s2 = re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1)
        
        # Converte tudo para min√∫sculo
        result = s2.lower()
        
        # Remove underscores duplos que podem ter sido criados
        result = re.sub('_{2,}', '_', result)
        
        # Remove underscores no in√≠cio e fim
        result = result.strip('_')
        
        return result

    def normalize_field_names(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Normaliza os nomes dos campos em um arquivo de dados para snake_case.
        
        Args:
            data (Dict[str, Any]): Dados do arquivo JSON
            
        Returns:
            Dict[str, Any]: Dados com nomes de campos normalizados
        """
        try:
            # Cria uma c√≥pia dos dados para n√£o modificar o original
            normalized_data = data.copy()
            
            # Atualiza a data de processamento
            normalized_data["processing_date"] = time.strftime("%Y-%m-%d %H:%M:%S")
            normalized_data["normalization_applied"] = True
            
            # Verifica se h√° campos para processar
            if "fields" not in data or not isinstance(data["fields"], list):
                print(f"‚ö†Ô∏è Estrutura de campos n√£o encontrada ou inv√°lida")
                return normalized_data
            
            original_fields = data["fields"]
            normalized_fields = []
            name_changes = []
            
            for field in original_fields:
                if not isinstance(field, dict) or "name" not in field:
                    print(f"‚ö†Ô∏è Campo inv√°lido ignorado: {field}")
                    continue
                
                # Cria uma c√≥pia do campo
                normalized_field = field.copy()
                
                # Normaliza o nome do campo
                original_name = field["name"]
                normalized_name = self.camel_to_snake_case(original_name)
                
                # Atualiza o campo
                normalized_field["name"] = normalized_name
                normalized_field["original_field_name"] = original_name
                
                # Registra a mudan√ßa se houve altera√ß√£o
                if original_name != normalized_name:
                    name_changes.append({
                        "original": original_name,
                        "normalized": normalized_name
                    })
                
                normalized_fields.append(normalized_field)
            
            # Atualiza os dados
            normalized_data["fields"] = normalized_fields
            normalized_data["normalization_summary"] = {
                "total_fields": len(normalized_fields),
                "fields_renamed": len(name_changes),
                "name_changes": name_changes
            }
            
            print(f"‚úÖ Normaliza√ß√£o conclu√≠da:")
            print(f"   üìä {len(normalized_fields)} campos processados")
            print(f"   üîÑ {len(name_changes)} campos renomeados")
            
            return normalized_data
            
        except Exception as e:
            error_msg = f"Erro durante normaliza√ß√£o: {e}"
            print(f"‚ùå {error_msg}")
            self.errors.append(error_msg)
            return data

    def process_files(self, file_extension: str = "json", normalize: bool = True) -> Dict[str, Any]:
        """
        Processa todos os arquivos detectados no diret√≥rio com normaliza√ß√£o opcional.
        
        Args:
            file_extension (str): Extens√£o dos arquivos a serem processados
            normalize (bool): Se deve aplicar normaliza√ß√£o snake_case
            
        Returns:
            Dict[str, Any]: Resultados do processamento
        """
        print(f"\nüöÄ Iniciando processamento de arquivos .{file_extension}")
        if normalize:
            print("üêç Normaliza√ß√£o snake_case: ATIVADA")
        print("=" * 60)
        
        start_time = time.time()
        files = self.detect_files(file_extension)
        
        if not files:
            print("‚ö†Ô∏è Nenhum arquivo encontrado para processar")
            return {
                "success": False,
                "processed_files": 0,
                "errors": self.errors,
                "execution_time": 0
            }
        
        processed_count = 0
        normalized_count = 0
        loaded_data = {}
        
        for file_path in files:
            print(f"\nüìã Processando: {file_path.name}")
            
            if file_extension.lower() == "json":
                # Carrega o arquivo original
                data = self.load_json_file(file_path)
                if data:
                    loaded_data[file_path.stem] = data
                    processed_count += 1
                    self.processed_files.append(str(file_path))
                    
                    # Aplica normaliza√ß√£o se solicitado
                    if normalize:
                        print(f"üîÑ Aplicando normaliza√ß√£o snake_case...")
                        normalized_data = self.normalize_field_names(data)
                        
                        # Salva o arquivo normalizado na pasta out
                        output_file = self.output_path / file_path.name
                        if self.save_json_file(normalized_data, output_file):
                            normalized_count += 1
                            print(f"‚úÖ Arquivo normalizado salvo: {output_file.name}")
                        else:
                            print(f"‚ùå Erro ao salvar arquivo normalizado: {output_file.name}")
            else:
                # Para outras extens√µes no futuro
                print(f"‚ö†Ô∏è Tipo de arquivo n√£o suportado ainda: .{file_extension}")
        
        execution_time = time.time() - start_time
        
        print(f"\n‚úÖ Processamento conclu√≠do!")
        print(f"   üìä {processed_count}/{len(files)} arquivos processados")
        if normalize:
            print(f"   üêç {normalized_count}/{processed_count} arquivos normalizados")
        print(f"   ‚è±Ô∏è Tempo de execu√ß√£o: {execution_time:.2f}s")
        
        if self.errors:
            print(f"   ‚ö†Ô∏è {len(self.errors)} erro(s) encontrado(s)")
        
        return {
            "success": processed_count > 0,
            "processed_files": processed_count,
            "normalized_files": normalized_count if normalize else 0,
            "total_files": len(files),
            "loaded_data": loaded_data,
            "errors": self.errors,
            "execution_time": execution_time,
            "normalization_applied": normalize
        }

    def get_file_summary(self, file_extension: str = "json") -> Dict[str, Any]:
        """
        Retorna um resumo dos arquivos no diret√≥rio.
        
        Args:
            file_extension (str): Extens√£o dos arquivos para an√°lise
            
        Returns:
            Dict[str, Any]: Resumo dos arquivos
        """
        files = self.detect_files(file_extension)
        
        summary = {
            "directory": str(self.data_path),
            "file_extension": file_extension,
            "total_files": len(files),
            "files": []
        }
        
        for file_path in files:
            file_info = {
                "name": file_path.name,
                "size_bytes": file_path.stat().st_size,
                "modified": time.ctime(file_path.stat().st_mtime)
            }
            
            # Para arquivos JSON, adiciona informa√ß√µes espec√≠ficas
            if file_extension.lower() == "json":
                data = self.load_json_file(file_path)
                if data:
                    file_info.update({
                        "table_name": data.get("table_name", "unknown"),
                        "total_fields": data.get("total_fields", 0),
                        "extraction_date": data.get("extraction_date", "unknown")
                    })
            
            summary["files"].append(file_info)
        
        return summary

    def test_normalization(self, test_names: List[str] = None) -> Dict[str, str]:
        """
        Testa a normaliza√ß√£o de nomes com exemplos.
        
        Args:
            test_names (List[str]): Lista de nomes para testar. Se None, usa exemplos padr√£o.
            
        Returns:
            Dict[str, str]: Mapeamento de nomes originais para normalizados
        """
        if test_names is None:
            test_names = [
                "stockLocal_priorityPoints",
                "stockLocal_defaultLocal", 
                "stockKeepingUnit_partnerId",
                "categoryId",
                "firstName",
                "lastName", 
                "camelCaseExample",
                "PascalCaseExample",
                "already_snake_case",
                "MixedCASE_example",
                "HTMLParser",
                "XMLHttpRequest"
            ]
        
        print("\nüß™ Testando normaliza√ß√£o snake_case:")
        print("-" * 50)
        
        results = {}
        
        for name in test_names:
            normalized = self.camel_to_snake_case(name)
            results[name] = normalized
            
            # Emoji para indicar se houve mudan√ßa
            status = "üîÑ" if name != normalized else "‚úÖ"
            print(f"{status} {name:25} -> {normalized}")
        
        return results

    def normalize_single_file(self, filename: str) -> bool:
        """
        Normaliza um √∫nico arquivo espec√≠fico.
        
        Args:
            filename (str): Nome do arquivo (com ou sem extens√£o)
            
        Returns:
            bool: True se processou com sucesso, False caso contr√°rio
        """
        # Garante que tem extens√£o .json
        if not filename.endswith('.json'):
            filename += '.json'
        
        file_path = self.data_path / filename
        
        if not file_path.exists():
            print(f"‚ùå Arquivo n√£o encontrado: {filename}")
            return False
        
        print(f"üîÑ Normalizando arquivo: {filename}")
        
        # Carrega o arquivo
        data = self.load_json_file(file_path)
        if not data:
            return False
        
        # Aplica normaliza√ß√£o
        normalized_data = self.normalize_field_names(data)
        
        # Salva na pasta out
        output_file = self.output_path / filename
        success = self.save_json_file(normalized_data, output_file)
        
        if success:
            print(f"‚úÖ Arquivo normalizado salvo em: {output_file}")
        
        return success

    def __str__(self) -> str:
        """Representa√ß√£o string da classe."""
        return f"DataWrangler(path='{self.data_path}', processed={len(self.processed_files)})"

    def __repr__(self) -> str:
        """Representa√ß√£o t√©cnica da classe."""
        return f"DataWrangler(data_path=Path('{self.data_path}'))"
